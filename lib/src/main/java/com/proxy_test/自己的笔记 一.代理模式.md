[参考](https://segmentfault.com/a/1190000040407024#:~:text=%E4%BB%A3%E7%90%86(Proxy)%E6%A8%A1%E5%BC%8F%E6%98%AF%E4%B8%80,%E6%96%B9%E5%BC%8F%E6%9D%A5%E6%89%A9%E5%B1%95%E8%AF%A5%E6%96%B9%E6%B3%95%E3%80%82)

##  一.代理模式

### 什么是代理模式

调用者不直接调用目标对象，而是通过代理对象间接调用目标对象

<img src="自己的笔记 一.代理模式.assets/image-20221014150140473.png" alt="image-20221014150140473" style="zoom:30%;" />

### 优点

+ 扩展性高

  比如 ImageLoader替换为Glide的情况

## 二. 动态代理的原理

优点：避免模板代码的编写

例如：Retrofit生产Service接口的实例

### 2.1 类加载的过程

.java文件 ---(编译)---> .class文件  ----(加载到jvm内存中)---> Class对象 ----(实例化)--->实例对象

动态代理会在内存中生成.class文件，使用此.class文件得到Class对象，然后实例得到实例对象

![image-20211021220842402](/Users/mac/Library/Application Support/typora-user-images/image-20211021220842402.png)

### 2.2 动态代理创建代理对象的过程

```java
  java11 Proxy.java
  @CallerSensitive
    public static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h) {
       
        Class<?> caller = System.getSecurityManager() == null ? null : Reflection.getCallerClass();
    
        //1.generateProxyClass创建.class文件
        //2.UNSAFE.defineClass 加载.class文件得到Class对象
        //3.通过Class对象得到构造器
        Constructor<?> cons = getProxyConstructor(caller, loader, interfaces);
    
        return newProxyInstance(caller, cons, h);
    }
```





```java 
java11 Proxy.java
 private static Class<?> defineProxyClass(Module m, List<Class<?>> interfaces) {

byte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, (Class[])interfaces.toArray(Proxy.EMPTY_CLASS_ARRAY), accessFlags);//内存中生成的.class文件

    Class<?> pc = UNSAFE.defineClass(proxyName, proxyClassFile, 0, proxyClassFile.length,      loader, (ProtectionDomain)null);//将.class文件生成想对应的Class对象
}
```



```java
java11 Proxy.java
Constructor<?> build() {
  
    Class proxyClass = defineProxyClass(this.module, this.interfaces);

    final Constructor cons;
    try {
        cons = proxyClass.getConstructor(Proxy.constructorParams);
    } catch (NoSuchMethodException var4) {
        throw new InternalError(var4.toString(), var4);
    }

    AccessController.doPrivileged(new PrivilegedAction<Void>() {
        public Void run() {
            cons.setAccessible(true);
            return null;
        }
    });
    return cons;
}
```

### 2.3 分析动态代理生成的文件

```java
通过使用反射调用ProxyGenerator，生成Massage接口的代理类
private static void proxy(){
        Class pClass1 = Class.forName("java.lang.reflect.ProxyGenerator");
        Method method = pClass1.getDeclaredMethod("generateProxyClass",String.class,Class[].class);
        method.setAccessible(true);
        System.out.println(method.getName());
        byte[] bytes = (byte[]) method.invoke(null,"Massage$Proxy",new Class[]{Massage.class});
        FileOutputStream fileOutputStream = new FileOutputStream("lib\""+"Massage$Proxy"+".class");
        fileOutputStream.write(bytes);
        fileOutputStream.flush();
        fileOutputStream.close();
}        
```

```java
public final class Massage$Proxy extends Proxy implements Massage {
    private static Method m1;
    private static Method m2;
    private static Method m3;
    private static Method m0;

    public Massage$Proxy(InvocationHandler var1) throws  {
        super(var1);
    }

    public final boolean equals(Object var1) throws  {
        try {
            return (Boolean)super.h.invoke(this, m1, new Object[]{var1});
        } catch (RuntimeException | Error var3) {
            throw var3;
        } catch (Throwable var4) {
            throw new UndeclaredThrowableException(var4);
        }
    }

    public final String toString() throws  {
        try {
            return (String)super.h.invoke(this, m2, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final void massage() throws  {
        try {
            super.h.invoke(this, m3, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final int hashCode() throws  {
        try {
            return (Integer)super.h.invoke(this, m0, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    static {
        try {
            m1 = Class.forName("java.lang.Object").getMethod("equals", Class.forName("java.lang.Object"));
            m2 = Class.forName("java.lang.Object").getMethod("toString");
            m3 = Class.forName("com.proxy_test.Massage").getMethod("massage");
            m0 = Class.forName("java.lang.Object").getMethod("hashCode");
        } catch (NoSuchMethodException var2) {
            throw new NoSuchMethodError(var2.getMessage());
        } catch (ClassNotFoundException var3) {
            throw new NoClassDefFoundError(var3.getMessage());
        }
    }
}
```



### 2.3 分析massage方法

代理类在调用massage（）方法时，会调用h.invoke方法，

+ h即为InvocationHandler，
+ this为代理对象
+ m3为massage方法对应的Method
+  (Object[])null 为参数对象

```java
 public final void massage() throws  {
        try {
            super.h.invoke(this, m3, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }


```

### 2.4 总结

生成的代理对象proxy，是ProxyGenerator生成的类的实例

该类是对接口Message的实现，实现类是在调用Message的方法时，

调用InvocationHandler方法，

所以在InvocationHandler.invoke中做代理即可

```java
final Mary mary = new Mary();
Object proxy = Proxy.newProxyInstance(
        ProxyTest.class.getClassLoader(),//类加载器
        new Class[]{Massage.class},//被代理类实现的接口
        new InvocationHandler() {//句柄
            @Override
            public Object invoke(Object o, Method method, Object[] objects) throws Throwable {
                System.out.println("record "+method.getName()+" start");
                method.invoke(mary, objects);
                return o;
            }
        });

((Massage) proxy).massage();
```

一句话:**动态代理 会创建一个实现了目标接口的类，类中每一个方法的实现就是就是调用句柄INvocationHandler**
