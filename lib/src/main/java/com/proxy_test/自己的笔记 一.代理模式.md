##  一.代理模式

### 什么是代理模式

调用者不直接调用对象，而是通过代理对象间接调用对象

### 优点

+ 扩展性高

  比如 ImageLoader替换为Glide的情况

## 二. 动态代理

优点：避免模板代码的编写

例如：要在一个类的每个方法执行之前打一个标记，如果采用硬编码，则会写很多相同的代码，此时使用动态代理，就可以避免写重复的代码

### 2.1 类加载的过程

.java文件 ---(编译)---> .class  ----(加载到jvm内存中)---> Class对象 ----(实例化)--->实例对象

动态代理会在内存中生成.class文件，使用此.class文件得到Class对象，然后实例得到实例对象

![image-20211021220842402](/Users/mac/Library/Application Support/typora-user-images/image-20211021220842402.png)





```java 
java11 Proxy.java

byte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, (Class[])interfaces.toArray(Proxy.EMPTY_CLASS_ARRAY), accessFlags);//内存中生成的.class文件

try {
    Class<?> pc = UNSAFE.defineClass(proxyName, proxyClassFile, 0, proxyClassFile.length, loader, (ProtectionDomain)null);//将.class文件生成想对应的Class对象
```



### 2.2 分析动态代理生成的额文件

```java
通过使用反射调用ProxyGenerator，生成Massage接口的代理类
private static void proxy(){
        Class pClass1 = Class.forName("java.lang.reflect.ProxyGenerator");
        Method method = pClass1.getDeclaredMethod("generateProxyClass",String.class,Class[].class);
        method.setAccessible(true);
        System.out.println(method.getName());
        byte[] bytes = (byte[]) method.invoke(null,"Massage$Proxy",new Class[]{Massage.class});
        FileOutputStream fileOutputStream = new FileOutputStream("lib\""+"Massage$Proxy"+".class");
        fileOutputStream.write(bytes);
        fileOutputStream.flush();
        fileOutputStream.close();
}        
```

```java
public final class Massage$Proxy extends Proxy implements Massage {
    private static Method m1;
    private static Method m2;
    private static Method m3;
    private static Method m0;

    public Massage$Proxy(InvocationHandler var1) throws  {
        super(var1);
    }

    public final boolean equals(Object var1) throws  {
        try {
            return (Boolean)super.h.invoke(this, m1, new Object[]{var1});
        } catch (RuntimeException | Error var3) {
            throw var3;
        } catch (Throwable var4) {
            throw new UndeclaredThrowableException(var4);
        }
    }

    public final String toString() throws  {
        try {
            return (String)super.h.invoke(this, m2, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final void massage() throws  {
        try {
            super.h.invoke(this, m3, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final int hashCode() throws  {
        try {
            return (Integer)super.h.invoke(this, m0, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    static {
        try {
            m1 = Class.forName("java.lang.Object").getMethod("equals", Class.forName("java.lang.Object"));
            m2 = Class.forName("java.lang.Object").getMethod("toString");
            m3 = Class.forName("com.proxy_test.Massage").getMethod("massage");
            m0 = Class.forName("java.lang.Object").getMethod("hashCode");
        } catch (NoSuchMethodException var2) {
            throw new NoSuchMethodError(var2.getMessage());
        } catch (ClassNotFoundException var3) {
            throw new NoClassDefFoundError(var3.getMessage());
        }
    }
}
```



### 2.3 分析massage方法

代理类在调用massage（）方法时，会调用h.invoke方法，

+ h即为InvocationHandler，
+ this为代理对象
+ m3为massage方法对应的Method
+  (Object[])null 为参数对象

```java
 public final void massage() throws  {
        try {
            super.h.invoke(this, m3, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }


```

### 2.4 总结

生成的代理对象proxy，是ProxyGenerator生成的类的实例

该类是对接口Message的实现，实现类是在调用Message的方法时，

调用InvocationHandler方法，

所以在InvocationHandler.invoke中做代理即可

```
final Mary mary = new Mary();
Object proxy = Proxy.newProxyInstance(
        ProxyTest.class.getClassLoader(),//类加载器
        new Class[]{Massage.class},//被代理类实现的接口
        new InvocationHandler() {//句柄
            @Override
            public Object invoke(Object o, Method method, Object[] objects) throws Throwable {
                System.out.println("record "+method.getName()+" start");
                method.invoke(mary, objects);
                return o;
            }
        });

((Massage) proxy).massage();
```
